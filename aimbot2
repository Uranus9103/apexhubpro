-- FULL FIXED: UI toggle + ESP (Drawing or BillboardGui) + Hitbox visual + InfiniteJump + Anti-AFK
-- Đặt vào StarterPlayer > StarterPlayerScripts (LocalScript)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ========== CẤU HÌNH ==========
local HITBOX_SIZE = Vector3.new(6, 6, 6) -- "hạ xuống tí" (thay đổi nếu muốn)
local HITBOX_TRANSPARENCY = 0.6
local HITBOX_COLOR = BrickColor.new("Really red")
local DRAWING_FALLBACK = true -- nếu Drawing không tồn tại sẽ dùng BillboardGui

-- ========== UI ==========
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "HelperGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local ToggleButton = Instance.new("TextButton")
ToggleButton.Size = UDim2.new(0,100,0,40)
ToggleButton.Position = UDim2.new(1,-110,1,-50)
ToggleButton.BackgroundColor3 = Color3.fromRGB(40,40,40)
ToggleButton.TextColor3 = Color3.new(1,1,1)
ToggleButton.Text = "Menu"
ToggleButton.Parent = ScreenGui

local Frame = Instance.new("Frame")
Frame.Size = UDim2.new(0,170,0,180)
Frame.Position = UDim2.new(1,-180,1,-240)
Frame.BackgroundColor3 = Color3.fromRGB(30,30,30)
Frame.Visible = false
Frame.Parent = ScreenGui

local UIListLayout = Instance.new("UIListLayout")
UIListLayout.Parent = Frame
UIListLayout.FillDirection = Enum.FillDirection.Vertical
UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
UIListLayout.Padding = UDim.new(0,6)

local function createToggle(name, parent, initState, callback)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(1,-10,0,36)
    btn.Position = UDim2.new(0,5,0,0)
    btn.BackgroundColor3 = Color3.fromRGB(60,60,60)
    btn.TextColor3 = Color3.new(1,1,1)
    btn.Font = Enum.Font.SourceSansBold
    btn.Text = (initState and "[ON] " or "[OFF] ") .. name
    btn.Parent = parent
    local state = initState
    btn.MouseButton1Click:Connect(function()
        state = not state
        btn.Text = (state and "[ON] " or "[OFF] ") .. name
        pcall(callback, state)
    end)
    return btn
end

ToggleButton.MouseButton1Click:Connect(function()
    Frame.Visible = not Frame.Visible
end)

-- ========== TRẠNG THÁI ==========
local ESP_Enabled = false
local HITBOX_Enabled = false
local InfiniteJumpEnabled = false

-- Data lưu per-player để dọn dẹp
local espData = {}    -- player -> {type="drawing" or "billboard", obj=..., conn=RenderSteppedConn, charCon=CharacterAddedCon, ancestryCon=AncestryCon}
local hitboxData = {} -- player -> {part = Part, weld = WeldConstraint, charCon = CharacterAddedCon}

-- Kiểm tra Drawing API
local DrawingAvailable = false
if typeof(Drawing) == "table" or (Drawing ~= nil and type(Drawing.new) == "function") then
    DrawingAvailable = true
end
if not DrawingAvailable and not DRAWING_FALLBACK then
    warn("[HelperGui] Drawing not available and fallback disabled. ESP will not show.")
end

-- ========== HÀM DỌN DẸP ESP ==========
local function cleanupESPForPlayer(player)
    local info = espData[player]
    if not info then return end
    -- disconnect render conn
    if info.conn and info.conn.Disconnect then
        pcall(function() info.conn:Disconnect() end)
    elseif info.conn then
        pcall(info.conn)
    end
    if info.charCon then
        pcall(function() info.charCon:Disconnect() end)
    end
    if info.ancestryCon then
        pcall(function() info.ancestryCon:Disconnect() end)
    end
    -- remove object
    if info.type == "drawing" and info.obj then
        pcall(function() info.obj:Remove() end)
    elseif info.type == "billboard" and info.obj then
        pcall(function() info.obj:Destroy() end)
    end
    espData[player] = nil
end

local function cleanupAllESP()
    for p,_ in pairs(espData) do
        cleanupESPForPlayer(p)
    end
end

-- ========== HÀM TẠO ESP CHO 1 NGƯỜI ==========
local function createESPForCharacter(player, character)
    if not player or player == LocalPlayer then return end
    -- dọn trước nếu có
    cleanupESPForPlayer(player)

    local head = character:FindFirstChild("Head")
    local humanoid = character:FindFirstChild("Humanoid")
    if not head or not humanoid then
        -- chờ Character hoàn thiện
        return
    end

    -- nếu Drawing có thì dùng Drawing (exploit) — else dùng BillboardGui
    if DrawingAvailable then
        local text = Drawing.new("Text")
        text.Center = true
        text.Outline = false
        text.Font = 3
        text.Size = 16
        text.Color = Color3.fromRGB(0,255,255)
        text.Visible = false
        text.Text = "[ " .. player.Name .. " ]"

        -- khi character removed -> xóa text
        local ancestryCon = character.AncestryChanged:Connect(function(_, parent)
            if not parent then
                pcall(function() text:Remove() end)
                cleanupESPForPlayer(player)
            end
        end)

        local renderCon
        renderCon = RunService.RenderStepped:Connect(function()
            if not ESP_Enabled then
                if text then pcall(function() text.Visible = false end) end
                return
            end
            if not head or not head.Parent then
                text.Visible = false
                return
            end
            if humanoid and humanoid.Health <= 0 then
                text.Visible = false
                return
            end
            local pos, onScreen = Camera:WorldToViewportPoint(head.Position)
            if onScreen then
                text.Position = Vector2.new(pos.X, pos.Y - 27)
                text.Text = "[ " .. player.Name .. " ]"
                text.Visible = true
            else
                text.Visible = false
            end
        end)

        espData[player] = {
            type = "drawing",
            obj = text,
            conn = renderCon,
            charCon = nil,
            ancestryCon = ancestryCon
        }

    else
        -- Billboard fallback (Roblox Studio / normal client)
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "ESP_Billboard_"..player.Name
        billboard.Size = UDim2.new(0,120,0,30)
        billboard.StudsOffset = Vector3.new(0,2,0)
        billboard.AlwaysOnTop = true

        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1,0,1,0)
        label.BackgroundTransparency = 1
        label.TextColor3 = Color3.fromRGB(0,255,255)
        label.Text = "[ " .. player.Name .. " ]"
        label.Font = Enum.Font.SourceSansBold
        label.TextScaled = true
        label.Parent = billboard

        billboard.Parent = head

        -- Clean up when char removed
        local ancestryCon = character.AncestryChanged:Connect(function(_, parent)
            if not parent then
                pcall(function() billboard:Destroy() end)
                cleanupESPForPlayer(player)
            end
        end)

        -- Update label visibility each frame (keeps it synced)
        local renderCon = RunService.RenderStepped:Connect(function()
            if not ESP_Enabled then
                if billboard.Parent then billboard.Enabled = false end
                return
            end
            if humanoid and humanoid.Health <= 0 then
                if billboard.Parent then billboard.Enabled = false end
                return
            end
            if billboard.Parent then billboard.Enabled = true end
        end)

        espData[player] = {
            type = "billboard",
            obj = billboard,
            conn = renderCon,
            charCon = nil,
            ancestryCon = ancestryCon
        }
    end
end

-- Tạo ESP cho player (được gọi khi bật hoặc khi player spawns)
local function ensureESPForPlayer(player)
    if not player or player == LocalPlayer then return end
    -- nếu đã có và ESP đang bật, không tạo nữa
    if espData[player] then return end
    local char = player.Character
    if char and char:FindFirstChild("Head") and char:FindFirstChild("Humanoid") then
        createESPForCharacter(player, char)
    end
    -- kết nối CharacterAdded để tạo lại khi respawn
    local charCon = player.CharacterAdded:Connect(function(cr)
        -- wait 0.05 - 0.2 tick để parts sẵn sàng
        task.wait(0.05)
        createESPForCharacter(player, cr)
    end)
    -- lưu charCon (nếu chưa lưu)
    if espData[player] then
        espData[player].charCon = charCon
    else
        -- lưu tạm để dọn dẹp nếu cần (nếu chưa có obj)
        espData[player] = espData[player] or {}
        espData[player].charCon = charCon
    end
end

-- ========== HÀM DỌN DẸP HITBOX ==========
local function cleanupHitboxForPlayer(player)
    local info = hitboxData[player]
    if not info then return end
    if info.part then
        pcall(function() info.part:Destroy() end)
    end
    if info.charCon then
        pcall(function() info.charCon:Disconnect() end)
    end
    hitboxData[player] = nil
end

local function cleanupAllHitboxes()
    for p,_ in pairs(hitboxData) do
        cleanupHitboxForPlayer(p)
    end
end

-- ========== HÀM TẠO HITBOX VISUAL ==========
local function createHitboxForCharacter(player, character)
    if not player or player == LocalPlayer then return end
    -- dọn trước
    cleanupHitboxForPlayer(player)

    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    -- tạo part làm visual (không ảnh hưởng hitbox thật)
    local part = Instance.new("Part")
    part.Name = "HitboxVisual_"..player.Name
    part.Size = HITBOX_SIZE
    part.Transparency = HITBOX_TRANSPARENCY
    part.CanCollide = false
    part.Anchored = false
    part.Material = Enum.Material.Neon
    part.BrickColor = HITBOX_COLOR
    part.Parent = workspace

    -- weld vào HRP để theo sát
    local weld = Instance.new("WeldConstraint")
    weld.Part0 = part
    weld.Part1 = hrp
    weld.Parent = part

    -- set initial CFrame
    part.CFrame = hrp.CFrame

    -- dọn khi character removed
    local ancestryCon = character.AncestryChanged:Connect(function(_, parent)
        if not parent then
            cleanupHitboxForPlayer(player)
        end
    end)

    hitboxData[player] = {
        part = part,
        weld = weld,
        charCon = ancestryCon
    }
end

local function ensureHitboxForPlayer(player)
    if not player or player == LocalPlayer then return end
    if hitboxData[player] then return end
    local char = player.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        createHitboxForCharacter(player, char)
    end
    -- respawn handling
    local charCon = player.CharacterAdded:Connect(function(cr)
        task.wait(0.05)
        createHitboxForCharacter(player, cr)
    end)
    if hitboxData[player] then
        -- if we already created the part we set charCon above inside createHitboxForCharacter
        hitboxData[player].charCon = hitboxData[player].charCon or charCon
    else
        hitboxData[player] = hitboxData[player] or {}
        hitboxData[player].charCon = charCon
    end
end

-- ========== TOGGLE HANDLERS ==========
local function enableESP(state)
    ESP_Enabled = state
    if not ESP_Enabled then
        cleanupAllESP()
        return
    end
    -- bật: tạo cho tất cả player hiện có
    for _,p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then
            ensureESPForPlayer(p)
        end
    end
end

local function enableHitbox(state)
    HITBOX_Enabled = state
    if not HITBOX_Enabled then
        cleanupAllHitboxes()
        return
    end
    for _,p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then
            ensureHitboxForPlayer(p)
        end
    end
end

local function enableInfiniteJump(state)
    InfiniteJumpEnabled = state
end

-- ========== KẾT NỐI SỰ KIỆN CHUNG ==========
-- khi player thêm vào server, nếu toggle đang bật thì cài đặt cho họ
Players.PlayerAdded:Connect(function(p)
    if p == LocalPlayer then return end
    if ESP_Enabled then
        ensureESPForPlayer(p)
    end
    if HITBOX_Enabled then
        ensureHitboxForPlayer(p)
    end
end)

Players.PlayerRemoving:Connect(function(p)
    cleanupESPForPlayer(p)
    cleanupHitboxForPlayer(p)
end)

-- Infinite Jump
UserInputService.JumpRequest:Connect(function()
    if InfiniteJumpEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
        LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState("Jumping")
    end
end)

-- Anti AFK (giữ nguyên)
LocalPlayer.Idled:Connect(function()
    -- Try to prevent kick for idling
    pcall(function()
        local vu = game:GetService("VirtualUser")
        vu:Button2Down(Vector2.new(0,0), Camera.CFrame)
        task.wait(1)
        vu:Button2Up(Vector2.new(0,0), Camera.CFrame)
    end)
end)

-- ========== TẠO NÚT TRONG UI ==========
createToggle("ESP", Frame, false, function(state) enableESP(state) end)
createToggle("Hitbox", Frame, false, function(state) enableHitbox(state) end)
createToggle("InfiniteJump", Frame, false, function(state) enableInfiniteJump(state) end)

-- nút tắt tất cả
local allOffBtn = Instance.new("TextButton")
allOffBtn.Size = UDim2.new(1,-10,0,36)
allOffBtn.Position = UDim2.new(0,5,0,0)
allOffBtn.BackgroundColor3 = Color3.fromRGB(120,40,40)
allOffBtn.TextColor3 = Color3.fromRGB(1,1,1)
allOffBtn.Font = Enum.Font.SourceSansBold
allOffBtn.Text = "Turn ALL OFF"
allOffBtn.Parent = Frame
allOffBtn.MouseButton1Click:Connect(function()
    -- set states
    enableESP(false)
    enableHitbox(false)
    enableInfiniteJump(false)
    -- update button texts
    for _,child in ipairs(Frame:GetChildren()) do
        if child:IsA("TextButton") and child ~= allOffBtn then
            local txt = child.Text
            if txt:match("%[ON%]") then
                child.Text = txt:gsub("%[ON%]", "[OFF]")
            end
        end
    end
end)

-- ========== Thông báo nhỏ khi script khởi tạo ==========
local success, _ = pcall(function()
    game.StarterGui:SetCore("SendNotification", {
        Title = "HelperGui";
        Text = "Script sẵn sàng — mở Menu để bật tính năng";
        Duration = 2;
    })
end)
